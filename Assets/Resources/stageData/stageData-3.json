{
    "stageOrder": [
        0,
        2,
        4,
        1,
        6,
        3,
        0,
        2,
        4,
        1,
        6,
        3,
        5,
        0,
        2,
        4,
        1,
        6,
        3,
        0,
        2,
        4,
        1,
        6,
        3,
        5
    ],
    "quizSets": [
        {
            "quizName": "자료구조의 기본",
            "questions": [
                "'자료구조'와 '알고리즘'은 설계될 프로그램의 성능에 큰 영향을 미치지는 않는다.",
                "흔히 쓰이는'Array(배열)'은 컴퓨터 자료구조의 종류가 아니다.",
                "타사 게임인 'LOL(League Of Legend)'에서 '큐를 돌린다'의 '큐'는 컴퓨터 자료구조의 Queue를 의미한다.",
                "'Queue'는 먼저 삽입한 것이 먼저 사용되는 자료구조이다.",
                "'Stack'은 흔히 '쌓는다'라고 표현하는데, 이는 먼저 삽입한 것이 아래에 깔려 나중에 나오기 때문이다.",
                "'C++'에서는 'Stack 자료구조'를 쉽게 사용할 수 있도록 라이브러리를 제공한다."
            ],
            "answers": [
                "프로그램의 질은 곧 좋은 '자료구조','알고리즘'이라고 해도 과언이 아닙니다.",
                "'Array(배열)'은 대표적인 컴퓨터 자료구조입니다.",
                "LOL의 유저들은 먼저 시작한 이가 먼저 게임을 하게 되는 것을 자료구조에 빗대어 'Queue(선입선출)'라고 부릅니다.",
                "'Queue'는 먼저 삽입한 것이 먼저 사용되는 선입선출의 자료구조입니다.",
                "'Stack'은 늦게 삽입한 것이 먼저 사용되는 후입선출의 자료구조입니다.",
                "'C++'에서는 Stack 라이브러리를 통해 Stack 자료형을 라이브러리로 제공합니다."
            ],
            "boolAnswers": [
                false,
                false,
                true,
                true,
                true,
                true
            ]
        },
        {
            "quizName": "연결 리스트와 배열",
            "questions": [
                "Linked List(연결 리스트)는 '노드'를 여러 개 이어놓은 형태의 자료구조이다.",
                "Linked List(연결 리스트)의 노드는 모두 포인터로 연결되어있다.",
                "Linked List(연결 리스트)는 Array(배열)에 비해 요소 삽입 및 삭제 비용이 비싸다.",
                "Linked List(연결 리스트)의 한 노드는 한 번에 여러 개의 노드를 가리킬 수는 없다.",
                "Array(배열)의 모든 요소는 같은 자료형(타입)을 가진다.",
                "삽입, 삭제, 정렬 등이 자주 필요한 프로그램에선 Array(배열)보다 Linked List(연결 리스트)를 사용한다."
            ],
            "answers": [
                "가상 데이터 단위 '노드'를 여러 개 이어놓은 형태의 자료구조를 Linked List(연결 리스트)라고 부릅니다.",
                "Linked List(연결 리스트)의 노드는 모두 포인터로 연결되어 있습니다.",
                "Linked List(연결 리스트)는 Array(배열)에 비해 요소 삽입 및 삭제 비용이 저렴합니다.",
                "Linked List(연결 리스트)의 한 노드는 한 번에 여러 개의 노드를 가리킬 수 있습니다.",
                "Array(배열)의 모든 요소는 같은 자료형(타입)을 가집니다.",
                "삽입, 삭제, 정렬 등이 자주 필요한 프로그램에선 요소 삽입 및 삭제 비용이 저렴한 Linked List(연결 리스트)를 사용합니다."
            ],
            "boolAnswers": [
                true,
                true,
                false,
                false,
                true,
                true
            ]
        },
        {
            "quizName": "트리(나무 아님)",
            "questions": [
                "'Tree(트리)' 자료구조는 노드들이 가지처럼 연결돼있다하여 Tree(트리)라는 이름으로 불리게 되었다.",
                "'Binary Tree(이진 트리)'는 모든 노드의 가지(포인터)가 2개 이상인 'Tree(트리)'를 말한다.",
                "'Complete Binary Tree(완전 이진 트리)'는 모든 노드의 가지가 0개 혹은 2개인 'Tree(트리)'를 말한다.",
                "'Full Binary Tree(포화 이진 트리)'는 모든 노드의 가지가 2개인 'Tree(트리)'를 말한다.",
                "트리를 순회하는 방법은 총 2가지가 존재한다.",
                "'Tree(트리)' 자료구조가 여러 개 모인 것을 'Forest(포레스트)'라고 한다."
            ],
            "answers": [
                "노드들이 가지처럼 연결돼있는 것이 꼭 나무의 모양인 지라 Tree(트리)라는 이름을 갖게 되었습니다.",
                "모든 노드의 가지(포인터)가 2개 이[하]인 'Tree(트리)'입니다...",
                "'Complete Binary Tree(완전 이진 트리)'는 모든 노드의 가지가 0개 혹은 2개인 'Tree(트리)'를 말합니다.",
                "마지막 노드는 제외해야 합니다! 트리가 무한히 커질 테니까요.",
                "트리를 순회하는 방법은 일반적으로 'Preorder', 'Inorder', 'Postorder'로 총 3가지가 존재합니다.",
                "나무가 여러 개 모인 것을 자료구조론에서도 숲이라고 합니다. 신기하죠?"
            ],
            "boolAnswers": [
                true,
                false,
                true,
                false,
                false,
                true
            ]
        },
        {
            "quizName": "공짜로 제공되는 여러 자료구조",
            "questions": [
                "프로그래머는 항상 int, char 등의 기본 자료형을 이용해 직접 자료구조를 만들어 사용해야 한다.",
                "'C++'에서는 'Stack 자료구조'를 쉽게 사용할 수 있도록 라이브러리로 제공한다.",
                "'Tree(트리)'나 'Linked List(연결 리스트)' 개념을 이용하여 Stack, Queue 등의 편리한 자료구조를 직접 만들 수 있다.",
                "C#에서 제공되는 'Dictionary(사전)' 자료구조는 key값을 받으면 key에 해당하는 자료를 돌려준다.",
                "삽입, 삭제, 정렬이 자주 일어나는 프로그램에는 배열 자료구조가 많이 쓰인다.",
                "'Tree(트리)'는 Array(배열)처럼 C에서 기본적으로 제공되는 자료구조다."
            ],
            "answers": [
                "요즘은 Stack, Queue 등의 자료구조를 편하게 사용할 수 있는 라이브러리가 제공됩니다!",
                "'C++'에서는 'Stack 자료구조'를 쉽게 사용할 수 있도록 라이브러리로 제공합니다.",
                "'Tree(트리)'나 'Linked List(연결 리스트)' 개념을 이용하면 Stack, Queue 뿐만 아니라 더 많은 자료구조를 만들 수 있어요.",
                "'Dictionary(사전)'는 실제 사전처럼 key값(똥)을 받아 해당하는 값(똥은 ~~~다.)을 돌려주는 편리한 자료구조랍니다.",
                "삽입, 삭제, 정렬이 자주 일어나는 프로그램에는 2단원에 나온 Linked List(연결 리스트) 자료구조가 많이 쓰이지요.",
                "'Tree(트리)'는 개념적인 자료구조입니다. 따로 제공되지 않습니다."
            ],
            "boolAnswers": [
                false,
                true,
                true,
                true,
                false,
                false
            ]
        }
    ],
    "lectureSets": [
        {
            "lectureName": "자료구조의 기본",
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "음... 반가워요.",
                "저는 자료구조론을 맡은 '송하윤'이라고 해요.",
                "음... 어... 이 자료구조론을 처음 접하는 분들은 조금 어려울 수 있겠지만,",
                "잘 따라올 거라 믿어 의심치 않아요.",
                "바로 수업에 들어가겠어요.",
                "음... 첫 장부터 아주 재미난 이야기들을 하고 있는데,",
                "별건 아니고, 자료구조를 왜 배우는가네요.",
                "그냥 '알고리즘'이랑 짬뽕해서, 프로그램의 성능을 올리기 위해서에요.",
                "자료구조엔 음... 대표적으로 Stack과 Queue가 있는데,",
                "많이 들어봤지요? '스택을 쌓는다', '롤 큐를 돌린다'... 뭐 그거에요.",
                "모른다고요? 음... 넘어가죠. 나중에 한번 쳐보세요.",
                "배열같은 것도 자료구조인데, 그니까, 그걸 그대로 써도 문제없으면 이걸 배울 이유가 없겠죠.",
                "배열이 삽입, 삭제, 정렬같은 걸 할 때 너무 안 좋아서, 뭐 기타 등등의 이유로 여러 자료구조가 필요한 겁니다.",
                "음... 쉬울 거라 생각하고,",
                "요즘 C++같은 언어에선 Stack, Queue같은 자료구조를 라이브러리로 제공하기도 하는데,",
                "Stack은 쌓이는 거라서 후입선출(Last In First Out), 그니까...",
                "늦게 들어온 게 맨 위에 쌓이잖아요. 맞죠?",
                "Queue는 파이프같은 거에 넣는 거라 보면 되고, 선입선출(First In First Out) 인 겁니다.",
                "어렵지 않죠?",
                "좋아요.",
                "오늘 수업은 여기까지에요.",
                "다음 시간까지 과제가 있어요.",
                "숙달된 조교가 나 대신 질문 받아줄 겁니다.",
                "$#^*(%...",
                "!@#%&...",
                "......"
            ]
        },
        {
            "lectureName": "Linked List(연결 리스트)",
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "음... 반가워요.",
                "저는 자료구조론을 맡은 '송하윤'이라고 해요.",
                "음... 어... 오늘은 링크드리스트에 대해 할 건데,",
                "오늘도 역시 잘 따라올 거라 믿어 의심치 않아요.",
                "(...난 따라간 적이 없는데...)",
                "음, 바로 수업에 들어가겠어요.",
                "음... 오늘도 첫 장부터 아주 재미난 이야기들을 하고 있는데,",
                "별건 아니고, 링크드리스트가 뭐냐면,",
                "아 영어로도 적어달라고요? 흠...",
                "Linked List(연결 리스트)는 말 그대로 노드끼리 연결해가지고 이어놓은 거에요.",
                "이게 무슨 소리냐, 각 노드가 Pointer(포인터)를 사용해서 서로 이어놓은...",
                "음... 그냥 포인터로 노드들끼리 연결돼서 Linked List(연결 리스트)에요.",
                "궁금하면 나중에 한번 쳐보세요.",
                "노드는 그냥.. 데이터 덩어립니다. 묻지 마세요.",
                "우리 숙달된 조교한테 물어보세요.",
                "Array(배열)이 이제 삽입, 삭제, 정렬같은 걸 할 때 비용이 비싸니까,",
                "링크드리스트를 쓰는 거죠.",
                "왜 Array(배열)가 비용이 비싸고, Linked List(연결 리스트)가 싸냐.",
                "그건 우리 숙달된 조교나 파란 창에 물어보면 알려줄 거에요.",
                "뭐 기타 등등의 이유로 여러 자료구조가 필요한 겁니다.",
                "음... 쉬울 거라 생각하고,",
                "노드는 포인터 하나만 가지고 한 노드만 가리키냐.",
                "그것도 아닙니다. 뭐 3 ~ 4개 가리키고 싶으면 가리켜도 됩니다.",
                "Linked List(연결 리스트)는 애당초 개념적인 자료구조라서,",
                "배열이랑 뭐가 달라? 하면 배열은 연속적인 메모리를 가리키는 자료구조고, 링크드리스트는 포인터로 메모리를 가리키는 방법이다~~.",
                "배열이랑 다르게 안에 들은 자료형도 달라도 됩니다.",
                "뭐 그런 겁니다. 어렵지 않죠?",
                "좋아요.",
                "오늘 수업은 여기까지에요.",
                "다음 시간까지 과제가 있어요.",
                "숙달된 조교가 나 대신 질문 받아줄 겁니다.",
                "시험 잘 보도록 해요.",
                "$#^*(%...",
                "!@#%&...",
                "......"
            ]
        },
        {
            "lectureName": "Tree(나무 아님)",
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "음... 반가워요.",
                "저는 자료구조론을 맡은 '송하윤'이라고 해요.",
                "음... 어... 오늘은 트리에 대해 할 건데,",
                "오늘도 역시 잘 따라올 거라 믿어 의심치 않아요.",
                "(...뭐라는 거야 맨날...)",
                "음, 바로 수업에 들어가겠어요.",
                "음... 오늘도 첫 장부터 아주 재미난 이야기들을 하고 있는데,",
                "별건 아니고, 트리가 뭐냐면,",
                "아 영어로... 흠...",
                "Tree(트리)는 링크드리스튼데, 가지처럼 그... 다단계처럼 쭉쭉 뻗어 나가서 나무모양을 띈 자료구조에요.",
                "이게 무슨 소리냐, 2개 이상의 Pointer(포인터)로 노드를 이어놓은...",
                "음... 그냥 한번 그려보세요. 나무 모양이라 Tree(트리)에요.",
                "궁금한 건 우리 숙달된 조교가 알려줄 겁니다.",
                "일자로만 연결된 Linked List(연결 리스트)를 쓰면, 안에 들은 요소를 찾을라면 맨 처음부터 다 돌아야 되잖아요.",
                "다음 노드는 처음 노드밖에 모르니까.",
                "쉽죠?",
                "좀 중화한 거라고 보면 됩니다.",
                "Tree(트리) 중에 Binary Tree(이진 트리)라는 건, 한 노드 당 가지가 2개 이하인 걸 말해요.",
                "음... 이해했을 거라 생각하고,",
                "그려보면 빨라요.",
                "그것 중에 가지가 1개인 게 없는, 그니까 0개 아니면 2개인 노드만 있는 트리는 Complete Binary Tree(완전 이진 트리),",
                "맨 아래 빼고 다 2개로 꽉 차 있는 트리는 Full Binary Tree(포화 이진 트리)입니다.",
                "뭐 그런 겁니다. 어렵지 않죠?",
                "이런 나무(Tree)가 또 여러 개 모이면... 뭐 숲(Forest)이라고도 부릅니다.",
                "좋아요.",
                "오늘 수업은 여기까지에요.",
                "다음 시간까지 과제가 있어요.",
                "숙달된 조교가 나 대신 질문 받아줄 겁니다.",
                "$#^*(%...",
                "!@#%&...",
                "......"
            ]
        },
        {
            "lectureName": "제공되는 여러 자료구조",
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "음... 반가워요.",
                "저는 자료구조론을 맡은 '송하윤'이라고 해요.",
                "음... 어... 오늘은 다른 자료구조들을 알려줄 건데,",
                "오늘도 역시 잘 따라올 거라 믿어 의심치 않아요.",
                "(...아오 ㅆ...)",
                "음, 바로 수업에 들어가겠어요.",
                "음... 오늘도 첫 장부터 아주 재미난 이야기들을 하고 있는데,",
                "별건 아니고, 지금까지 배운 걸로 자료구조를 만들라면 만들 수 있겠어요?",
                "만들면 우리 연구실에 초빙하겠어요.",
                "음... 아무튼,",
                "항상 만들어서 쓸 필요는 없고, 대개 뭐 이미 있는 것들로 할 수 있습니다.",
                "다 라이브러리를 제공해줍니다.",
                "Stack, Queue, Dictionary, Map, Bag, List... 같은 것도,",
                "저 Linked List, Tree같은 개념으로 이미 구현이 되어있는 겁니다.",
                "우리 숙달된 조교와 함께 실습해볼 시간이 있었으면 좋겠군요.",
                "Dictionary(사전)은 Key값을 주면 거기에 해당하는 값을 찾기 용이하게 돼있는 자료구조고,",
                "List는 Linked List를 가시적으로 구현해놓은 겁니다.",
                "음... 얘기보단 써보는 게 빠르겠군요.",
                "우리 숙달된 조교와 함께...",
                "'!@#%&...'",
                "...앞에서 배운 Linked List(연결 리스트), Array(배열), Tree(트리)로,",
                "어떤 친절한 사람이 Stack, Queue, Dictionary, List같은 편리한 자료구조를 직접 만들어 놓은 거에요.",
                "그냥 사용하면 되고, 또 이것만으로 다루긴 너무 거대한 데이터를 다룰 때에는 직접 만들어서, 사용하면 되겠죠?",
                "오늘 수업은 여기까지에요.",
                "이번 학기, 고생했어요.",
                "시험 잘 보도록 해요.",
                "......",
                "..."
            ]
        }
    ],
    "examSets": [
        {
            "examName": "연결 리스트와 자료구조",
            "questions": [
                "다음 중 자료구조로 볼 수 없는 것은?",
                "다음 중 라이브러리로 제공되지 않는 자료구조를 고르시오.",
                "Queue와 가장 밀접한 관련이 있는 단어를 고르시오.",
                "현재 플레이하고 있는 게임의 이름은?",
                "삽입, 삭제, 정렬이 자주 일어나는 프로그램에 가장 사용하기 부적합할 것이라 사료되는 자료구조는?",
                "Stack과 가장 밀접한 관련이 있는 단어를 고르시오."
            ],
            "exampleSets": [
                {
                    "examples": [
                        "Stack",
                        "Queue",
                        "int",
                        "Dictionary"
                    ],
                    "answerExample": "int는 자료구조가 아닌 자료형입니다."
                },
                {
                    "examples": [
                        "Stack",
                        "Linked List",
                        "Dictionary",
                        "List"
                    ],
                    "answerExample": "Linked List는 개념적인 자료구조입니다. 그 개념을 이용하여 List, Dictionary 등을 만듭니다."
                },
                {
                    "examples": [
                        "선입선출",
                        "선입후출",
                        "FILO",
                        "LIFO"
                    ],
                    "answerExample": "Queue는 선입선출, First In First Out(FIFO)의 자료구조입니다."
                },
                {
                    "examples": [
                        "프린세스메이커",
                        "아이의꿈",
                        "컴공생키우기",
                        "미사일연속발사시스템"
                    ],
                    "answerExample": "컴공생키우기를 플레이해주셔서 감사합니다!"
                },
                {
                    "examples": [
                        "Array(배열)",
                        "Linked List(연결 리스트)",
                        "Tree(트리)",
                        "Graph(그래프)"
                    ],
                    "answerExample": "Array(배열)은 삽입, 삭제, 정렬에 약한 자료구조입니다."
                },
                {
                    "examples": [
                        "선입선출",
                        "후입후출",
                        "FIFO",
                        "LIFO"
                    ],
                    "answerExample": "쌓는다고 표현되는 'Stack'은 후입선출, Last In First Out(LIFO)의 자료구조입니다."
                }
            ],
            "answers": [
                2,
                1,
                0,
                2,
                0,
                3
            ]
        },
        {
            "examName": "트리와 여러 자료구조들",
            "questions": [
                "(맨 아래만 제외하고) 부족한 가지없이 완벽한 모양을 갖는 Binary Tree(이진 트리)를 부르는 명칭은?",
                "Key 값(똥)을 제공했을 때, Key에 해당하는 값(똥은 ~~다.)을 받고 싶을 때 사용하는 자료구조의 이름은?",
                "다음 중 Linked List 개념으로 만들어진 자료구조가 아닌 것은?",
                "Linked List(연결 리스트), Tree(트리) 등의 자료 구조의 요소들은 무엇으로 연결되어 있는가?",
                "지금 강의를 하고 계신 교수님의 이름은 무엇일까요?",
                "Tree(트리)는 하나의 노드당 몇 개의 가지를 갖는 자료구조를 의미하는가?"
            ],
            "exampleSets": [
                {
                    "examples": [
                        "Tree(트리)",
                        "Binary Tree(이진 트리)",
                        "Christmas Tree(크리스마스 트리)",
                        "Full Binary Tree(포화 이진 트리)"
                    ],
                    "answerExample": "완전 이진 트리와 헷갈릴 수 있지만, 포화 이진 트리입니다."
                },
                {
                    "examples": [
                        "List(리스트)",
                        "Stack(스택)",
                        "Heap(힙)",
                        "Dictionary(사전)"
                    ],
                    "answerExample": "Dictionary는 정말 사전처럼 Key값으로 해당하는 값을 찾고자 할 때 쓰입니다."
                },
                {
                    "examples": [
                        "Array(배열)",
                        "Tree(트리)",
                        "List(리스트)",
                        "Queue(큐)"
                    ],
                    "answerExample": "배열을 대체하고자 나온 개념적인 자료구조가 Linked List입니다. 답은 Array(배열)!"
                },
                {
                    "examples": [
                        "Pointer(포인터)",
                        "Format(포맷)",
                        "Struct(구조체)",
                        "Class(클래스)"
                    ],
                    "answerExample": "위 자료구조들의 요소들은 모두 Pointer(포인터)로 연결하는 것이랍니다."
                },
                {
                    "examples": [
                        "표창우",
                        "송하윤",
                        "김선일",
                        "박솔휘"
                    ],
                    "answerExample": "지금 자료구조론을 가르치고 계신 교수님의 이름은 바로 '송하윤'입니다!"
                },
                {
                    "examples": [
                        "1개",
                        "2개",
                        "3개",
                        "상관없음"
                    ],
                    "answerExample": "가지의 개수는 상관없습니다! 가지의 개수가 2개인 트리는 따로 Binary Tree(이진 트리)라고 부릅니다."
                }
            ],
            "answers": [
                3,
                3,
                0,
                0,
                1,
                3
            ]
        }
    ]
}