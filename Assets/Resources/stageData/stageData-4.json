{
    "stageOrder": [
        0,
        2,
        4,
        1,
        6,
        3,
        0,
        2,
        4,
        1,
        6,
        3,
        5,
        0,
        2,
        4,
        1,
        6,
        3,
        0,
        2,
        4,
        1,
        6,
        3,
        5
    ],
    "quizSets": [
        {
            "quizName": "알고리즘의 개요",
            "questions": [
                "'자료구조'와 '알고리즘'은 설계될 프로그램의 성능의 대부분을 결정한다고 봐도 무방하다.",
                "컴퓨터 분야의 '알고리즘'이란 문제 해결을 위해 컴퓨터가 사용할 정확한 절차를 의미한다.",
                "'알고리즘'은 사용자에게 큰 틀을 제시하며, 명확하게 기술될 필요는 없다.",
                "'알고리즘' 학문은 컴퓨터 분야에만 한정되어 있으며, 1900년대 처음 등장했다.",
                "현 시대 AI의 학습 알고리즘은 완벽하며, 잘만 짜여져 있다면 항상 완벽한 학습 결과를 도출한다.",
                "알고리즘을 프로그래밍 언어가 아닌 그림으로 미리 표현하는 것을 순서도(Flow Chart)라고 한다."
            ],
            "answers": [
                "프로그램의 질은 어떤 '자료구조','알고리즘'를 사용했는가로 결정된다해도 과언이 아닙니다.",
                "이 단원에서 논하는 '알고리즘'은 문제 해결을 위해 컴퓨터가 사용하는 절차를 의미합니다.",
                "'알고리즘'은 반드시 '입력'부터, '출력'까지 명확하게 기술되어야 합니다.",
                "'알고리즘' 학문은 고대 바빌로니아의 농경 관리에도 사용된 학문이라고 합니다. (오래됨)",
                "현 시대 AI의 학습 알고리즘은 인간과 비슷하여, 작은 결함들이 숨어있다고 합니다. ",
                "알고리즘을 미리 그림으로 나타낸 것을 순서도(Flow Chart)라고 합니다."
            ],
            "boolAnswers": [
                true,
                true,
                false,
                false,
                false,
                true
            ]
        },
        {
            "quizName": "Search & Sorting (탐색과 정렬)",
            "questions": [
                "정렬이란 어느 기준에 의거하여 순서대로 나열하는 행위를 말한다.",
                "이진 탐색(Binary Search)는 언제 어디서든 적용할 수 있는 방법이다.",
                "이진 탐색(Binary Search)는 중앙값을 기준으로 다음 탐색지를 계속 재선정하여, 총 탐색 시간을 줄이는 방법이다.",
                "이진 탐색(Binary Search)는 중앙값을 기준으로 해야 하기 때문에 미리 Sorting(정렬)이 필요하다.",
                "Sorting(정렬)에는 슬로우정렬, 권정렬, 선택정렬, 삽입정렬 등이 있다.",
                "퀵, 삽입, 선택, 합병정렬은 모두 동일한 시간 복잡도를 가진다."
            ],
            "answers": [
                "사전도 알파벳 순서에 의거하여 abc순으로 정렬되어있지요.",
                "이진 탐색(Binary Search)는 미리 정렬된 자료구조에만 적용할 수 있는 방법입니다.",
                "이진 탐색(Binary Search)는 중앙값을 기준으로 탐색지를 반씩 줄여나가는 방법입니다. 그 속도가 빠릅니다.",
                "이진 탐색(Binary Search)는 중앙값을 기준으로 해야하기 때문에 Sorting(정렬)이 필요합니다!",
                "슬로우정렬, 권정렬은 없고, 퀵정렬, 합병정렬이 존재합니다!",
                "퀵정렬, 합병정렬이 제시된 정렬 중 O(nlogn)으로 가장 빠릅니다."
            ],
            "boolAnswers": [
                true,
                false,
                true,
                true,
                false,
                false
            ]
        },
        {
            "quizName": "Path Finding (길찾기 알고리즘)",
            "questions": [
                "길찾기 알고리즘은 흔히 지도, 네비게이션 등에 실제로 이용된다.",
                "길찾기 알고리즘은 최장경로 알고리즘이라고도 부른다.",
                "다익스트라 알고리즘은 한 노드마다 노드로부터 갈 수 있는 모든 경로를 알고 있는 알고리즘이다.",
                "A* 알고리즘은 다익스트라와 달리 이동 불가능한 지역을 미리 검사하여 배제한다.",
                "길의 이동 가능 여부가 자주 변하는 경우 A*보다 다익스트라 알고리즘이 편하다.",
                "최단 경로를 찾는 알고리즘에는 크루스칼, 프림 등 다양한 알고리즘이 사용된다."
            ],
            "answers": [
                "길찾기 알고리즘은 말그대로 흔히 지도나 네비게이션에 이용됩니다.",
                "길찾기 알고리즘은 최단경로 알고리즘이라고도 부릅니다.",
                "다익스트라의 특징은 한 위치로부터 갈 수 있는 모든 위치의 비용 정보를 모든 노드마다 저장한다는 것입니다.",
                "A*와 다익스트라의 차이는 이동 불가능한 지역을 미리 검사하여 배제한다는 것입니다.",
                "길의 이동 가능 여부가 자주 갱신되는 경우, 이동 가능 여부를 미리 배제하는 A*가 조금 더 효율적입니다.",
                "크루스칼, 프림, 다익스트라 등은 모두 최단 경로를 찾는 알고리즘입니다. 'Spanning Tree 찾기'라고도 합니다."
            ],
            "boolAnswers": [
                true,
                false,
                true,
                true,
                false,
                true
            ]
        },
        {
            "quizName": "Greedy Algorithm (욕심쟁이 알고리즘)",
            "questions": [
                "욕심쟁이 알고리즘은 항상 최적의 결과를 도출한다.",
                "욕심쟁이 알고리즘은 현재 가치가 높은 행위를 항상 우선으로 하는 것이 욕심쟁이같다하여 붙여진 이름이다.",
                "'거스름돈 돌려주기'는 욕심쟁이 알고리즘의 대표적인 사용처이다.",
                "욕심쟁이 알고리즘은 최악의 결과를 도출하는 경우가 대부분이다.",
                "현재 '알고리즘' 수업을 강의하는 교수님의 이름은 '정균락'이다.",
                "욕심쟁이 알고리즘은 길찾기의 크루스칼, 프림 알고리즘에 적용될 수 있다."
            ],
            "answers": [
                "욕심쟁이 알고리즘은 항상 최적도, 최악도 아닌 결과를 주로 도출합니다.",
                "욕심쟁이 알고리즘은 항상 '현재'를 기준으로 가치를 판단합니다. 그 모습이 욕심쟁이 같지 않나요?",
                "'거스름돈 돌려주기'는 욕심쟁이 알고리즘의 대표적인 실패 사례입니다.",
                "욕심쟁이 알고리즘은 보통 최적도, 최악도 아닌 결과를 도출합니다.",
                "현재 '알고리즘' 수업을 강의하는 교수님은 '정균락' 교수님입니다!",
                "욕심쟁이 알고리즘은 길찾기의 크루스칼, 프림 외에도 많은 상황에 사용되는 효율 좋은 알고리즘입니다."
            ],
            "boolAnswers": [
                false,
                true,
                false,
                false,
                true,
                true
            ]
        }
    ],
    "lectureSets": [
        {
            "lectureName": "알고리즘의 개요",
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "허허.. 저는 정균락이라고 하는데, 들어봤는지 모르겠어요.",
                "아무튼 반가워요.",
                "음... 지금 배우는 알고리즘은 중요하긴한데...",
                "실제로 잘 쓰이진 않아요. 쓸 일이 없어요. 이미 구현이 돼있기 때문에...",
                "아무튼... 수업해보죠.",
                "음... 별 건 아니고, 알고리즘...의 역사같은 건데",
                "이런 건 보통 흥미가 잘 없겠지만 한번 보도록 하죠...",
                "자료구조랑 해가지고 프로그램을 만들 때, 가장 효율...성을 판단하는데 중요하죠.",
                "똑같이 굴러가도 프로그래머에 따라 효율성이 천차만별이에요. 여러분이 그 좋은 프로그래머가 되어야겠죠.",
                "정확하게 뭐하고, 뭐하고, 뭐하고... 그런 프로세스같은게 알고리즘이에요.",
                "일상 생활과도 연관있을 것 같지 않나요?",
                "음... 그 알고리즘을 만들 때 보통 Flow Chart(순서도)를 먼저 그리는데,",
                "다들 한번씩 봤을 거에요. 넘어가죠...",
                "...모른다고요? 허허...",
                "그냥.. 정확하고, 입력있고... 출력있고... 하면 돼요. 할 거면 정확하게 해야죠.",
                "컴퓨터에만 있는 건 아니고, 옛날 고대 바빌로니아 때부터 썼다고 하네요.",
                "농지 경영...? 같은 거에 썼나봐요.",
                "그 요즘 핫한 AI같은 거에도 제일 중요한 게 이 알고리즘인데,",
                "아직 완벽하진 않아요. 빵꾸날 때도 있죠 뭐. 사람보단 적게 빵꾸나요 그래도",
                "......",
                "...흠 오늘은 첫 수업이니까 여기까지 하도록 하죠.",
                "과제는 음... 뭐 낼 것도 없어요.",
                "다음 시간에 보죠."
            ]
        },
        {
            "lectureName": "탐색(Search)과 정렬(Sorting) ",
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "허허.. 저는 정균락이라고 하는데, 두 번째 시간이니까 알겠죠.",
                "......",
                "음... 바로 수업하죠.",
                "탐색과 정렬...",
                "음... 비교적 중요한 것 같아요.",
                "보통 프로그램들은 자료를 갖고 있고, 그 자료를 찾아서 써야되니까요.",
                "중요하다기보다... 대표적이라고 하는 게 맞겠군요. 물론 중요한 것도 맞아요.",
                "자료 탐색을 앞에서부터 쭉 하는 건 바보같은 짓이죠.",
                "자료가 10억개 있으면 어쩔 거에요. 9억 번째에 있는 자료를 찾을려면 틀어놓고 밥이라도 먹고 와야 돼요.",
                "그래서 보통 정렬을 해놓죠. 찾기 쉽게",
                "어떤 기준을 사용해서(의거해서) 정렬을 해놓으면, 탐색 알고리즘으로 빠르게 찾을 수 있어요.",
                "정렬에는... 음...",
                "제일 빠른 게 퀵정렬, 합병정렬...",
                "그 다음 삽입정렬, 거품정렬... 같은 게 있는데 뭐 어차피 다 라이브러리에 써져있어서 그냥 쓰면 돼요.",
                "필요없어요.",
                "그래도 평균적으로 가장 빠른 게 퀵정렬이라는 건 알아줬으면 좋겠네요.",
                "그렇게 정렬하고나서, 이제 탐색을 해야죠.",
                "Binary Search(이진 탐색)이라는 방법이 있는데,",
                "꼭 정렬된 자료구조에만 사용해야돼요.",
                "정렬된 중앙값보다 찾으려는 값이 더 크면 반절 잘라서 뒤에꺼만(큰 부분만) 검사하고,",
                "또 중앙값 보고 잘라내고... 그런 식이니까요.",
                "이해가 안 가면... 한번 검색해보세요. 바로 알 수 있어요.",
                "아무튼 계속 중앙값 보고, 계속 검사할 곳을 반토막내니까, 무식하게 앞에서 쭉 보는 것보단 빠르겠죠.",
                "이런 걸 시간 복잡도가 낮다~~ 뭐 그렇게 말하는데, 그냥 시간이 적게 걸린단 겁니다.",
                "어려웠던 것 같네요. 오늘은 여기까지 하죠.",
                "시험 잘 봐요."
            ]
        },
        {
            "lectureName": "Path Finding(길찾기) Algorithm",
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "허허.. 저는 정균락이라고 하는데, 세 번째 시간이니까 이젠 알겠죠.",
                "......",
                "음... 오늘은 Path Finding(길찾기)네요.",
                "좀 어려운 개념이죠. 자주 쓰이고",
                "음... 수업하죠.",
                "말 그대로 길찾기 알고리즘이에요. 길찾는데 쓰이겠죠 뭐...",
                "네비게이션, 지도 같은 거...",
                "뭐 여러 가지가 있는데,",
                "직접 찾아보는 게 빠르겠지만, Dijkstra(다익스트라), A*(에이스타)가 대표적이에요.",
                "Kruskal(크루스칼), Prim(프림) 같은 것도 있네요.",
                "이건 어디에 좀 메모해뒀으면 좋겠네요.",
                "다익스트라는 지역마다 타 지역으로 갈 수 있는 모든 경로의 Cost,",
                "그걸 지역마다 다 구해서 저장해주는 거에요. Cost는 비용이죠. 알겠죠 뭐.",
                "아무튼 다 저장하고 있어서, 어떤 곳으로 가고 싶을 때 저장한 경로로 가면 돼요.",
                "시작에 좀 우당탕탕 저장해야겠지만, 한번 하고 나면 편하겠죠.",
                "조금 무식하다는 느낌을 받을 수도 있겠어요",
                "그래서 A*(에이스타)는 다 저장하는 건 아니고, 경로를 구할 때 가능성이 없는 건 다 빼고 시작하는 거에요.",
                "좀 스마트한가요? 장단점은 있어요.",
                "아무튼 경로가 계속 바뀌는 경우엔 A*(에이스타) 써야겠죠.",
                "좀 어렵나요?",
                "시험 쉽게 낼게요. 걱정하지마요 게임이니까.",
                "여기까지만 하죠.",
                "과제는 없어요."
            ]
        },
        {
            "lectureName": "Greedy(욕심쟁이) Algorithm",
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "허허.. 저는 정균락이라고 하는데, 마지막 시간인데 설마 모르겠어요.",
                "......",
                "수업하죠.",
                "음... 욕심쟁이 알고리즘 들어본 학생 있어요?",
                "...",
                "뭐 못 들어봤을 수 있죠.",
                "말 그대로 욕심쟁이같아서 붙은 이름이에요.",
                "눈 앞에 있는 것만 생각해서(현재 기준으로), 가장 좋아보이는 걸(가치가 높은 것) 골라서 실행하는 거에요.",
                "뭐 어렵지 않죠.",
                "효율도 좋아요. 간단해가지고.",
                "근데 항상 명확한 답을 줄 것 같나요?",
                "아니죠. 아닐 것 같죠. 욕심쟁이니까.",
                "최적의 해...는 아니고, 최악의 해는 아닌, 뭐 썩 괜찮은 해를 주는 거에요.",
                "아무튼 좋은 것만을 고르다보니까 최악은 아닌 거죠.",
                "응용분야가 넓은데, 명확한 답이 안나오는 그런 문제에 효율적으로 잘 쓰일 것 같아요.",
                "...자세한 건 검색해봐요.",
                "저번 시간에 배운 길찾기 알고리즘에도 유용하게 쓰여요.",
                "크루스칼, 프림, 다익스트라... 기억나나요?",
                "...안날 수도 있죠 뭐.",
                "거스름돈 돌려주기라고 욕심쟁이 알고리즘의 대표적인 예제가 있긴한데, 이건 실패 사례에요.",
                "욕심쟁이라서 실패할 때도 있어요.",
                "500원 하나, 300원 두개가 있어요, 근데 600원을 돌려줘볼게요.",
                "300원 두개를 돌려주는게 맞죠?",
                "근데 욕심쟁이는 시작에 500원을 주는 거에요. 지금만 보니까, 300원보다 500원을 주는게 빨리 끝날 것 같은 거죠.",
                "그러면 이제 거스름돈을 더 줄 수가 없어요.",
                "그런 문제에요.",
                "......",
                "오늘은 여기까지하죠.",
                "시험 잘 봤으면 좋겠어요."
            ]
        }
    ],
    "examSets": [
        {
            "examName": "탐색과 정렬, 알고리즘의 기본",
            "questions": [
                "다음 중 알고리즘을 코드화하기 전, 미리 그림으로 나타내는 것을 지칭하는 말은?",
                "어느 기준에 의거하여 요소들을 순서대로 나열하는 것을 지칭하는 말은?",
                "정렬된 배열의 중앙값을 기준으로 탐색지를 반으로 줄여나가며 요소를 찾는 탐색법을 무엇이라 하는가?",
                "현재 플레이하고 있는 게임의 이름은?",
                "흔히 사용되는 정렬법 중 평균적으로 가장 빠른 정렬법은?",
                "다음 중 알고리즘의 구성에 반드시 존재해야 하는 요소가 아닌 것은?"
            ],
            "exampleSets": [
                {
                    "examples": [
                        "Flow Chart(순서도)",
                        "WordPad(워드패드)",
                        "Hangeul(한글)",
                        "그림판"
                    ],
                    "answerExample": "알고리즘은 코드화하기 전, 미리 Flow Chart(순서도)로 나타내는 게 좋습니다."
                },
                {
                    "examples": [
                        "Search(탐색)",
                        "Sorting(정렬)",
                        "PathFinding(길찾기)",
                        "Greedy(욕심쟁이)"
                    ],
                    "answerExample": "사전도 알파벳 순서에 의거하여 abc.. 순서로 정렬되어있지요."
                },
                {
                    "examples": [
                        "Electric Search",
                        "Research",
                        "Web Search",
                        "Binary Search"
                    ],
                    "answerExample": "Binary Search(이진 탐색)은 정렬된 배열의 중앙값을 기준으로 탐색지를 줄여가는 탐색법입니다."
                },
                {
                    "examples": [
                        "리그오브레전드",
                        "컴공생키우기",
                        "던전앤파이터",
                        "미사일연속발사시스템"
                    ],
                    "answerExample": "컴공생키우기를 플레이해주셔서 감사합니다!"
                },
                {
                    "examples": [
                        "Merge Sort(합병정렬)",
                        "Bubble Sort(거품정렬)",
                        "Quick Sort(퀵정렬)",
                        "Insert Sort(삽입정렬)"
                    ],
                    "answerExample": "퀵정렬과 합병정렬은 같은 시간 복잡도를 가지지만, 평균적으로는 퀵정렬이 조금 더 빠릅니다."
                },
                {
                    "examples": [
                        "입력",
                        "출력",
                        "정밀성",
                        "활력"
                    ],
                    "answerExample": "알고리즘은 정밀해야하며, 입력과 출력이 반드시 있어야 합니다. 활력도 있으면 좋지요."
                }
            ],
            "answers": [
                0,
                1,
                3,
                1,
                2,
                3
            ]
        },
        {
            "examName": "대중적이고 멋진 알고리즘들",
            "questions": [
                "최단 경로를 찾는 알고리즘 중, 노드 각각이 갈 수 있는 모든 경로의 정보를 알고 있는 알고리즘을 무엇이라 하는가?",
                "다음 중 알고리즘 수업에서 배우지 않은 것은?",
                "다음 중 욕심쟁이 알고리즘에 관련된 설명은?",
                "최단 경로 알고리즘에 대하여 옳지 않은 설명은?",
                "지금 강의를 하고 계신 교수님의 이름은 무엇일까요?",
                "다음 중 최단 경로 알고리즘이 아닌 것은?"
            ],
            "exampleSets": [
                {
                    "examples": [
                        "Dijkstra(다익스트라) 알고리즘",
                        "Strassen(스트라쎈) 알고리즘",
                        "Greedy(욕심쟁이) 알고리즘",
                        "Youtube(유튜브) 알고리즘"
                    ],
                    "answerExample": "Dijkstra(다익스트라) 알고리즘은 노드 각각이 갈 수 있는 모든 경로의 정보를 알고 있는 알고리즘입니다."
                },
                {
                    "examples": [
                        "Flow Chart(순서도)",
                        "Dijkstra(다익스트라)",
                        "Greedy(욕심쟁이)",
                        "Data Structure(자료구조)"
                    ],
                    "answerExample": "자료구조는 지금 알고리즘 수업과 관련이 없지요."
                },
                {
                    "examples": [
                        "최적의 해를 구하는데 사용된다.",
                        "항상 미래를 기준으로 가치가 높은 것을 선택하는 알고리즘이다.",
                        "근사값을 구하는데 주로 이용되며, 높은 효율로 최적도, 최악도 아닌 결과를 주로 도출한다.",
                        "'거스름돈 돌려주기'는 욕심쟁이 알고리즘의 주 사용 영역이다."
                    ],
                    "answerExample": "욕심쟁이 알고리즘은 최적도, 최악도 아닌 결과를 주로 도출하지만, 그 효율이 높다는 것이 장점입니다. "
                },
                {
                    "examples": [
                        "'길찾기 알고리즘'이라고도 불린다.",
                        "항상 최장의 경로를 탐색하며, 그 종류로는 크루스칼, 프림 등이 있다.",
                        "주로 네비게이션, 지도 어플리케이션에 이용되는 알고리즘이다.",
                        "다이나믹 프로그래밍 기법은 이 최단 경로 알고리즘과 연관성이 아주 깊다."
                    ],
                    "answerExample": "최단 경로 알고리즘은 항상 '최단'의 경로를 탐색합니다."
                },
                {
                    "examples": [
                        "정균락",
                        "이가은",
                        "김선일",
                        "허준혁"
                    ],
                    "answerExample": "지금 알고리즘 과목을 가르치고 계신 교수님은 바로 '정균락'입니다!"
                },
                {
                    "examples": [
                        "Dijkstra(다익스트라)",
                        "Prim(프림)",
                        "Dynamic(다이나믹)",
                        "Kruskal(크루스칼)"
                    ],
                    "answerExample": "Dynamic(다이나믹)...은 한번 구글링해보면 도움이 됩니다."
                }
            ],
            "answers": [
                3,
                3,
                2,
                1,
                0,
                2
            ]
        }
    ]
}