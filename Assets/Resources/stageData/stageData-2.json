{
    "stageOrder": [
        0,
        2,
        4,
        1,
        6,
        3,
        0,
        2,
        4,
        1,
        6,
        3,
        5,
        0,
        2,
        4,
        1,
        6,
        3,
        0,
        2,
        4,
        1,
        6,
        3,
        5
    ],
    "quizSets": [
        {
            "quizName": "C++의 기본, 클래스",
            "questions": [
                "C++는 C 언어와 무관한 언어이다.",
                "C++는 객체지향 프로그래밍 언어이다.",
                "클래스는 객체를 구현하기 위해 사용한다.",
                "클래스는 '개'의 속성보단 '개 한 마리'에 매핑되는 개념이다.",
                "C++이 C와 다른 점은 클래스를 지원한다는 것이다.",
                "클래스는 Class 키워드를 이용하여 사용할 수 있다."
            ],
            "answers": [
                "C++는 C언어를 확장해 만든 언어로 그 관계가 아주 깊습니다.",
                "C++는 클래스를 활용한 '객체'지향 프로그래밍 언어입니다. ",
                "클래스는 객체를 표현하고 구현하기 위해 고안된 개념입니다.",
                "클래스는 개 한 마리 자체가 아닌 '개'라는 속성 및 개념을 정의합니다.",
                "클래스의 지원은 C와 대조되는 큰 특징입니다.",
                "클래스는 Class 키워드를 이용하여 사용합니다."
            ],
            "boolAnswers": [
                false,
                true,
                true,
                false,
                true,
                true
            ]
        },
        {
            "quizName": "C++의 클래스 상속",
            "questions": [
                "C++에서 클래스 상속의 개념은 유전적 상속과 비슷하다.",
                "부모 클래스는 상속한 자식 클래스의 멤버를 사용할 수 있다.",
                "자동차라는 부모 클래스가 있다면, 외제차라는 자식 클래스가 존재할 수 있다.",
                "자식 클래스는 하나만 가질 수 있다.",
                "자식 클래스는 자식 클래스를 상속하는 자식 클래스를 가질 수 없다.",
                "부모 클래스는 자식 클래스를 3개까지 가질 수 있다."
            ],
            "answers": [
                "C++에서 클래스 상속의 개념은 부모 자식간 유전적 상속의 개념과 비슷합니다.",
                "부모 클래스는 상속한 자식 클래스의 멤버를 사용할 수 없습니다. 반대입니다.",
                "자동차라는 부모 클래스는 자동차의 생산지를 기준으로 자식 클래스로 나누어질 수 있습니다.",
                "자식 클래스는 문법상 무한히 만들 수 있습니다. 현실과 같지요.",
                "자식 클래스는 자식 클래스를 상속하는 또 다른 자식 클래스를 가질 수 있습니다. 현실과 같네요.",
                "부모 클래스는 문법상 갯수가 제한되어 있지 않습니다."
            ],
            "boolAnswers": [
                true,
                false,
                true,
                true,
                false,
                false
            ]
        },
        {
            "quizName": "C++의 변수 지킴이",
            "questions": [
                "접근 지정자는 C++의 변수 지킴이이며, 변수의 보호 수준을 정해준다.",
                "이 게임의 제작자는 C++을 이용해 게임을 제작했다. (Unity는 C#을 사용합니다.)",
                "접근 지정자의 종류엔 public, private, protected가 있다.",
                "public은 변수에의 접근을 누구든 허용한다는 의미이다.",
                "private은 상속관계에 있는 클래스에만 접근을 허용하는 것이다.",
                "접근 지정자의 허용 범위는 private < protected < public 이다."
            ],
            "answers": [
                "접근 지정자는 C++의 변수 지킴이이며, 변수의 보호 수준을 정해줍니다.",
                "C++에서 ++가 더 붙은 C#으로 제작되었습니다.",
                "접근 지정자의 종류엔 public, private, protected가 있습니다.",
                "public은 변수에의 접근을 누구든 허용한다는 의미입니다. 위험하겠네요.",
                "private은 자기 자신에게만 허용하는 것이며, 상속관계에서만 허용하는 것은 protected입니다.",
                "접근 지정자의 허용 범위는 private < protected < public가 맞습니다."
            ],
            "boolAnswers": [
                true,
                false,
                true,
                true,
                false,
                true
            ]
        },
        {
            "quizName": "C++의 생성자와 소멸자",
            "questions": [
                "생성자는 객체가 생성될 때 자동으로 호출되는 함수이다.",
                "소멸자는 생성자와 달리 선언하지 않으면 호출되지 않는다.",
                "생성자의 이름은 클래스의 이름과 동일하다.",
                "소멸자는 클래스의 이름 뒤에 ~를 붙이면 소멸자이다.",
                "소멸자는 여러 개 존재할 수 있다.",
                "생성자는 매개변수에 따라 여러 개 존재할 수 있다."
            ],
            "answers": [
                "생성자는 객체가 생성될 때 자동으로 호출되는 함수입니다.",
                "소멸자도 생성자와 같이 선언하지 않아도 기본 소멸자가 호출됩니다.",
                "생성자는 클래스의 이름과 동일하며, 뒤에 ()가 붙습니다.",
                "소멸자는 클래스의 이름 앞에 ~를 붙이면 소멸자입니다.",
                "소멸자는 여러 개 존재할 수 없습니다.",
                "생성자는 매개변수에 따라 여러 개 존재할 수 있습니다."
            ],
            "boolAnswers": [
                true,
                false,
                true,
                false,
                false,
                true
            ]
        }
    ],
    "lectureSets": [
        {
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "음... 반가워요.",
                "저는 C++을 맡은 '송하윤'이라고 해요.",
                "오늘은 C++의 기본에 대해서 얘기할거에요",
                "첫 날이니까 말이죠?",
                "C++는 C언어를 확장시킨 언어로 객체지향 프로그래밍 언어에요.",
                "저번 학기에 절차지향... 어쩌고 배웠어요?",
                "안 배웠다구요?",
                "그럼 이 수업을 들을 수가 없을텐데...",
                "흠... 뭐 어쩔 수 없군요. 넘어가도록 해요.",
                "아무튼 객체를 구현하려고 클래스라는 개념이 추가된 거에요.",
                "C++ 소스 파일의 확장자는 .cpp .cxx .c++ 등 운영체제에 따라 다양해요.",
                "알겠죠?",
                "...모르겠으면 숙달된 우리 조교에서 물어보도록 해요.",
                "객체지향 언어가 가지는 특징은 추상화, 캡슐화, 정보은닉, 상속성, 다형성 등이 있어요.",
                "이게 무슨 말이냐면,",
                "음... 클래스를 통해서 뭐 객체로 이케저케 감싸면 저렇게 된다는 거에요.",
                "직접 쳐보는 게 빠르겠군요.",
                "객체란 건 실생활에서 우리가 인식할 수 있는 개, 고양이 같은 거에요.",
                "클래스는 그 객체의 속성같은 거라고 할 수 있어요.",
                "클래스는 class 키워드를 이용하여 선언할 수 있고, 멤버 변수, 멤버 함수, 생성자, 소멸자 등으로 돼있어요.",
                "생성자는 클래스의 객체가 실제로 선언될 때,",
                "그니까 '개의 속성'으로 '개 한 마리'가 탄생할 때 불러지는 함수같은 거에요.",
                "소멸자는 사라질 때고요.",
                "생성자는 여러 개 있을 수도 있고, 소멸자는 여러 개 있을 수 없어요.",
                "음... 어렵나요?",
                "오늘 수업은 여기까지에요.",
                "모르는 건 우리 연구실의 숙달된 조교들에게 물어보도록 해요.",
                "오호!",
                "아하!"
            ]
        },
        {
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "음... 반가워요.",
                "저는 C++을 맡은 '송하윤'이라고 해요.",
                "두 번째 시간이죠?",
                "오늘은 클래스 상속에 대해서 배워보도록 해요.",
                "거기, 유전자 상속이 뭔지 알아요?",
                "음... 모를 리가 없을 텐데.",
                "모를 수도 있죠 뭐.",
                "아무튼 C++의 클래스 상속도 이 유전적 상속과 비슷해요.",
                "클래스는 부모와 자식 클래스로 나뉘는데, 자식 클래스는 부모의 멤버를 상속받죠.",
                "뭐 멤버 변수, 함수 같은 거 말하는 거에요.",
                "예를 들어, 자동차라는 부모 클래스가 있다면, 휘발유, 경유차 자식 클래스가 있는 거죠.",
                "대충 뭔지 감이 오나요?",
                "실제 손자, 손녀처럼 자식 클래스도 자식 클래스를 가지는 것이 가능해요.",
                "아, 물론 여러 자식 클래스를 가질 수도 있어요.",
                "음, 오늘 수업은 여기까지에요. 시험 잘 보도록 해요."
            ]
        },
        {
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "음... 반가워요.",
                "저는 C++을 맡은 '송하윤'이라고 해요.",
                "오늘은 C++의 변수 지킴이에 대해서 알아볼거에요.",
                "C++에서는 그걸 접근 지정자라고 불러요.",
                "접근 지정자의 종류는 pubilc, private, protected이 있는데,",
                "public은 변수로의 접근을 어디에서든 허용하는 것이고,",
                "private은 클래스 내부에서만,",
                "protected는 상속 관계에 있는 클래스에만 허용하는 아이에요.",
                "음... 쉽죠?",
                "private는 나 혼자 쓰겠다는 거고,",
                "protected는 가족끼리 쓰겠다는 거고,",
                "public은 모두가 함께 쓰겠다는 거에요.",
                "정리하면 허용 범위는 private < protected < public 이라고 할 수 있겠어요.",
                "오늘 수업은 여기까지에요.",
                "모르는 건 조교한테 물어봐요."
            ]
        },
        {
            "texts": [
                "(해당 강의를 스킵하면 추가 점수를 받을 수 없습니다.)",
                "음... 반가워요.",
                "저는 자료구조론을 맡은 '송하윤'이라고 해요.",
                "벌써 마지막 시간이군요.",
                "오늘은 클래스의 생성자와 소멸자에 대해서 알아볼 거에요.",
                "첫 번째 시간에 잠깐 봤던 거 기억나죠?",
                "음...",
                "생성자는 객체가 생성될 때 자동으로 호출되어 객체를 초기화해주는 역할을 하는 거에요.",
                "그니까, 생성될 때 한번 불러지는 함수에요.",
                "생성자의 이름은 클래스와 이름이 같고, 또 생성자는 반환값이 없다는 특징이 있어요.",
                "생성자를 명시하지 않아도, 자동으로 디폴트(기본) 생성자가 호출돼요.",
                "알겠나요?",
                "생성자는 디폴트 아닌 걸로 매개 변수를 넣어서 쓸 수도 있어요.",
                "뭐 입맛에 따라 여러 개가 존재할 수 있겠죠?",
                "흠...",
                "그렇다면 소멸자는 무엇이냐.",
                "객체가 소멸될 때 불러지는 애라고 할 수 있어요.",
                "소멸될 때 자동으로 호출되어 마무리 작업을 해주는 역할을 하는 겁니다.",
                "소멸자는 클래스 이름과 같지만, 앞에 ~가 붙는다는 차이가 있어요.",
                "하나밖에 존재할 수 없구요.",
                "흠... 좀 어려웠나요?",
                "오늘 수업은 여기까지 하도록 해요.",
                "시험 잘 보도록 해요."
            ]
        }
    ],
    "examSets": [
        {
            "examName": "C++의 클래스와 상속",
            "questions": [
                "객체지향 프로그래밍이 가지는 특징이 아닌 것은?",
                "Class의 구성요소가 아닌 것은?",
                "다음 중 객체지향 언어가 아닌 것은?",
                "다음 중 C++ 소스 파일의 확장자가 될 수 없는 것은?",
                "다음 중 C++에서 말하는 클래스 상속의 개념을 적용시키기에 부적절한 것은?",
                "C++의 특징으로 잘못된 것은?"
            ],
            "exampleSets": [
                {
                    "examples": [
                        "추상화 (abstraction)",
                        "캡슐진화 (Capsule Evolution)",
                        "상속성 (inheritance)",
                        "다형성 (polymorphism)"
                    ],
                    "answerExample": "캡슐 진화는 디지몬 밖에 못합니다."
                },
                {
                    "examples": [
                        "멤버함수",
                        "이영자",
                        "생성자",
                        "소멸자"
                    ],
                    "answerExample": "클래스의 구성요소는 멤버 변수, 멤버 함수, 생성자, 소멸자 등으로 구성됩니다."
                },
                {
                    "examples": [
                        "C언어",
                        "C++",
                        "C#",
                        "Java"
                    ],
                    "answerExample": "C++, C#, Java는 객체지향 언어로 C언어는 절차지향언어입니다."
                },
                {
                    "examples": [
                        ".cpp",
                        ".cxx",
                        ".css",
                        ".c++"
                    ],
                    "answerExample": "cpp, c++, cxx는 C++ 소스 파일의 확장자가 맞으며 css는 다른 확장자입니다."
                },
                {
                    "examples": [
                        "동물 - 강아지",
                        "집 - 아파트",
                        "직원 - 영업직 직원",
                        "사람 - 흑염룡"
                    ],
                    "answerExample": "사람의 안에는 흑염룡이 잠자고 있을 수도 있습니다. 하지만 지금은 좀;"
                },
                {
                    "examples": [
                        "객체지향언어이다.",
                        "C언어와 C++의 가장 큰 차이는 클래스의 존재 유무라고도 할 수 있다.",
                        "C++은 B++ 다음의 언어로, 그 다음 언어는 D++이다.",
                        "C++에서 상속은 굉장히 중요한 개념이다."
                    ],
                    "answerExample": "C++은 객체지향언어로, 상속과 클래스는 중요한 개념이며, C언어와 가장 큰 차이라고 할 수 있습니다."
                }
            ],
            "answers": [
                1,
                1,
                0,
                2,
                3,
                2
            ]
        },
        {
            "examName": "클래스의 접근지정자, 생성자, 소멸자",
            "questions": [
                "다음 중 클래스의 생성자와 소멸자에 대한 설명으로 잘못된 것은?",
                "다음 중 클래스의 생성자와 소멸자에 대한 설명이 아닌 것은?",
                "다음 중 접근 지정자에 대한 설명으로 옳지 않은 것은?",
                "다음 중 클래스의 생성자에 대한 설명이 아닌 것은?",
                "다음 중 접근 지정자가 아닌 것은?",
                "접근 지정자에 대한 설명으로 틀린 것은?"
            ],
            "exampleSets": [
                {
                    "examples": [
                        "생성자는 클래스 내에 하나만 존재할 수 있다.",
                        "소멸자는 클래스 내에 하나만 존재할 수 있다.",
                        "생성자는 선언하지 않으면 디폴트 생성자가 호출된다.",
                        "소멸자는 선언하지 않으면 디폴트 소멸자가 호출된다."
                    ],
                    "answerExample": "생성자는 클래스 내에 매개변수를 달리하여 여러 개 존재할 수 있습니다."
                },
                {
                    "examples": [
                        "생성자는 객체가 생성될 때 자동으로 호출되어 객체를 초기화해주는 역할을 할 수 있다.",
                        "소멸자는 객체가 소멸될 때 자동으로 호출되어 마무리 작업을 해주는 역할을 한다.",
                        "소멸자의 이름은 '카잔'이다.",
                        "생성자의 이름은 클래스의 이름과 동일하다."
                    ],
                    "answerExample": "카잔은 '던전앤파이터'에 나오는 '소멸의 신'입니다."
                },
                {
                    "examples": [
                        "접근 지정자를 정해주지 않으면 자동으로 private으로 선언된다.",
                        "접근 지정자의 역할은 접근의 허용 범위를 정하는 것이다.",
                        "접근 지정자만 선언할 수 있다.",
                        "접근 지정자는 데이터를 숨기고 보호하는 역할을 한다."
                    ],
                    "answerExample": "접근 지정자만 선언하는 것은 불가능합니다."
                },
                {
                    "examples": [
                        "생성자는 객체가 생성될 때 자동으로 호출되어 객체를 초기화해주는 역할을 할 수 있다.",
                        "생성자의 특징은 클래스와 이름이 같고, 반환 값이 없다는 특징이 있다.",
                        "만약 생성자를 명시적으로 작성하지 않았다면 자동으로 디폴트 생성자가 호출된다.",
                        "생성자는 객체가 소멸될 때 자동으로 호출되어 마무리 작업을 해주는 역할을 한다."
                    ],
                    "answerExample": "4번은 소멸자에 대한 설명입니다."
                },
                {
                    "examples": [
                        "public",
                        "processing",
                        "private",
                        "protected"
                    ],
                    "answerExample": "접근 지정자는 pubilc, private, protected로 구성됩니다."
                },
                {
                    "examples": [
                        "멤버 변수는 private으로 지정하는 것이 바람직하다.",
                        "접근 지정은 프로그램 캡슐화를 위해 필요하다.",
                        "private 접근 지정자는 이상한 사람이 헌팅하는 것을 막아준다.",
                        "접근 지정자는 중요한 멤버를 보호하고 일부엔 허용하는 역할을 한다."
                    ],
                    "answerExample": "접근 지정자가 헌팅까지 막아주지는 못 합니다. 할 수 있으면 좋을 텐데요."
                }
            ],
            "answers": [
                0,
                2,
                2,
                3,
                1,
                2
            ]
        }
    ]
}